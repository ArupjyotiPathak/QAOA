{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "bcd33220",
   "metadata": {},
   "source": [
    "# Optimization pipeline"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "240add21",
   "metadata": {},
   "source": [
    "## QUBO Marix"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "902a74bd",
   "metadata": {},
   "source": [
    "We have a square matrix W"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "c62004f1",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "W = [[153, 510, 706, 966, 581, 455, 70 , 160, 372, 157, 567, 342, 398],\n",
    "    [0  , 664, 997, 598, 507, 197, 311, 479, 310, 581, 417, 376, 275],\n",
    "    [0  , 0  , 28 , 744, 390, 437, 491, 645, 880, 618, 374, 455, 211],  \n",
    "    [0  , 0  , 0  , 491, 265, 410, 664, 804, 1070,768, 259, 499, 310],\n",
    "    [0  , 0  , 0  , 0  , 400, 514, 902, 990, 1261,947, 418, 635, 636], \n",
    "    [0  , 0  , 0  ,0   , 0  , 168, 522, 634, 910, 593, 19 , 284, 239], \n",
    "    [0  , 0  , 0  , 0  ,0  , 0   , 232, 124, 163, 439, 757, 389, 123],\n",
    "    [0  , 0  , 0  , 0  ,0  , 0   , 0  , 154, 406, 133, 508, 273, 355], \n",
    "    [0  , 0  , 0  , 0  ,0  , 0   , 0  , 0  , 276, 43 , 623, 358, 498],\n",
    "    [0  , 0  , 0  , 0  ,0  , 0   , 0  , 0  , 0  , 318, 898, 633, 761], \n",
    "    [0  , 0  , 0  , 0  ,0  , 0   , 0  , 0  , 0  , 0  , 582, 315, 464], \n",
    "    [0  , 0  , 0  , 0  ,0  , 0   , 0  , 0  , 0  , 0  , 0  , 275, 221], \n",
    "    [0  , 0  , 0  , 0  , 0 , 0   , 0  , 0  , 0  , 0  , 0  , 0  , 247]]   \n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "500e2b6f",
   "metadata": {},
   "source": [
    "We need to find such a vector <v| = [V1,V2,...,Vn], where n is the number of columns, of the square matrix W, which\n",
    "c = <v|W|v> has a minimum value. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "178356c1",
   "metadata": {},
   "source": [
    "## Ð¡alculation qubo sum"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "858655f1",
   "metadata": {},
   "source": [
    "This function should be minimal for the optimal solution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 118,
   "id": "88b838c1",
   "metadata": {},
   "outputs": [],
   "source": [
    "def calc_qubo_value(M, v):\n",
    "    quboSum = 0\n",
    "    for i in range(0,len(v)):\n",
    "        for j in range(0, len(v)):\n",
    "            quboSum += v[i]*M[i][j]*v[j]\n",
    "    return quboSum\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0ff9d8c2",
   "metadata": {},
   "source": [
    "## Make random vector"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f8c1dae7",
   "metadata": {},
   "source": [
    "A helper function to create an initial random condition and compare the optimal value with a random solution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "2313f02e",
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "def make_random_vector(nsize):\n",
    "    v = [];\n",
    "    for x in range(0, nsize):\n",
    "        v.append(random.random())\n",
    "    return v    \n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8efbefd9",
   "metadata": {},
   "source": [
    "Creating a random vector"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "e90d99f9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.2479867345564598, 0.721369652454255, 0.9561687237997859, 0.34331435526189835, 0.5569300018928304, 0.5863439784833088, 0.6926191188027525, 0.6641929628097331, 0.04018661203726415, 0.6837627993058603, 0.5617769170322446, 0.1189749297075049, 0.6789212822160954]\n"
     ]
    }
   ],
   "source": [
    "vct = make_random_vector(len(W[0]))\n",
    "print(vct)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "14960d78",
   "metadata": {},
   "source": [
    "Checking the calculation of the objective function on a random vector"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "c227f64e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "qubo sum:9248.153785155506\n"
     ]
    }
   ],
   "source": [
    "qubo = calc_qubo_value(W, make_random_vector(len(W[0])))\n",
    "print('qubo sum:' + str(qubo)) "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9e51c28a",
   "metadata": {},
   "source": [
    "## Randomize weight matrix "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "91f1d1fa",
   "metadata": {},
   "source": [
    "Random mixing of the weight matrix of the problem."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fd17a9ad",
   "metadata": {},
   "source": [
    "Needed for accidentally reducing the size of a problem or accidentally splitting a task into parts"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "039b7677",
   "metadata": {},
   "source": [
    "Function of random shuffling of vector indices"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "id": "7200cfa7",
   "metadata": {},
   "outputs": [],
   "source": [
    "#rng = np.random.default_rng()\n",
    "def random_index(nsize, vindex = []):\n",
    "    if len(vindex) == nsize:\n",
    "        return vindex\n",
    "    index = random.randint(0,nsize-1)\n",
    "#    index = rng.integers(0,nsize-1)\n",
    "    for i in range(0,len(vindex)):\n",
    "        if vindex[i] == index: \n",
    "            return random_index(nsize, vindex)\n",
    "    vindex.append(index)\n",
    "    return random_index(nsize, vindex)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8d48f0c3",
   "metadata": {},
   "source": [
    "Checking for random mixing of indices"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "id": "371b4288",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0, 3, 6, 9, 4, 5, 8, 2, 1, 7]\n"
     ]
    }
   ],
   "source": [
    "print(random_index(10))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "13ad68d2",
   "metadata": {},
   "source": [
    "Weight matrix shuffle function by shuffle vector"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "id": "fec68194",
   "metadata": {},
   "outputs": [],
   "source": [
    "def randomize_matrix(M, rv):\n",
    "    newM = [([0]*len(M[0])) for i in range(len(M[0]))]\n",
    "    for i in range(0, len(rv)):\n",
    "        for j in range(0, len(rv)):\n",
    "            if i > j:\n",
    "                newM[i][j] = 0\n",
    "            else:\n",
    "                if rv[i] <= rv[j]:\n",
    "                    newM[i][j] = M[rv[i]][rv[j]]\n",
    "                else:\n",
    "                    newM[i][j] = M[rv[j]][rv[i]]\n",
    "    return newM"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fe9520a9",
   "metadata": {},
   "source": [
    "Checking the Random Mixing Functions of the Weight Matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "id": "d91b3f1a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0, 3, 6, 9, 4, 5, 8, 2, 1, 7, 11, 10, 12]\n"
     ]
    }
   ],
   "source": [
    "\n",
    "rv = random_index(len(W[0]))\n",
    "print(rv)\n",
    "newW = randomize_matrix(W, rv)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0bb2990e",
   "metadata": {},
   "source": [
    "## Matrix split"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7abacb10",
   "metadata": {},
   "source": [
    "Dividing a square matrix into two parts. It is necessary to reduce the dimension of the problem."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "id": "e722b6f6",
   "metadata": {},
   "outputs": [],
   "source": [
    "def split_matrix(M, size):\n",
    "    M1 = []\n",
    "    M2 = []\n",
    "    if len(M) < size:\n",
    "        return []\n",
    "    for i in range(0, size):\n",
    "        M1.append([])\n",
    "        for j in range(0, size):\n",
    "            M1[i].append(M[i][j])\n",
    "    for i in range(size, len(M)):\n",
    "        M2.append([])\n",
    "        for j in range(size, len(M)):\n",
    "            M2[i-size].append(M[i][j])\n",
    "            \n",
    "    return [M1, M2]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e952f0c7",
   "metadata": {},
   "source": [
    "Checking the division of the matrix into parts"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "id": "7eb24319",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[[153, 510, 706, 966, 581, 455, 70], [0, 664, 997, 598, 507, 197, 311], [0, 0, 289, 744, 390, 437, 491], [0, 0, 0, 491, 265, 410, 664], [0, 0, 0, 0, 400, 514, 902], [0, 0, 0, 0, 0, 168, 522], [0, 0, 0, 0, 0, 0, 232]], [[154, 406, 133, 508, 273, 355], [0, 276, 43, 623, 358, 498], [0, 0, 318, 898, 633, 761], [0, 0, 0, 582, 315, 464], [0, 0, 0, 0, 275, 221], [0, 0, 0, 0, 0, 247]]]\n"
     ]
    }
   ],
   "source": [
    "listM = split_matrix(W, 7)\n",
    "print(listM)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cc9fe0db",
   "metadata": {},
   "source": [
    "## Creating a Problem Graph"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "efba984c",
   "metadata": {},
   "source": [
    "Create a vertex vector for a graph"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "id": "89394579",
   "metadata": {},
   "outputs": [],
   "source": [
    "def create_vector_nodes(size):\n",
    "    v = [i for i in range(size)]\n",
    "    return v"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd95a4e9",
   "metadata": {},
   "source": [
    "Checking the generated vertex vector for the graph"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "id": "0e035c1f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
     ]
    }
   ],
   "source": [
    "print(create_vector_nodes(10))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4a62de5b",
   "metadata": {},
   "source": [
    "create edges from weight marix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "id": "244ef1f9",
   "metadata": {},
   "outputs": [],
   "source": [
    "def create_edges(M):\n",
    "    edges = []\n",
    "    for i in range(0, len(M)):\n",
    "        for j in range (i + 1, len(M)):\n",
    "            if M[i][j] != 0:\n",
    "                edges.append((i,j))\n",
    "    return edges        \n",
    "                \n",
    "            "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b7d95de8",
   "metadata": {},
   "source": [
    "Checking the Created Graph edges"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "id": "fe259706",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10), (0, 11), (0, 12), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (1, 10), (1, 11), (1, 12), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (2, 10), (2, 11), (2, 12), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9), (3, 10), (3, 11), (3, 12), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), (4, 10), (4, 11), (4, 12), (5, 6), (5, 7), (5, 8), (5, 9), (5, 10), (5, 11), (5, 12), (6, 7), (6, 8), (6, 9), (6, 10), (6, 11), (6, 12), (7, 8), (7, 9), (7, 10), (7, 11), (7, 12), (8, 9), (8, 10), (8, 11), (8, 12), (9, 10), (9, 11), (9, 12), (10, 11), (10, 12), (11, 12)]\n"
     ]
    }
   ],
   "source": [
    "print(create_edges(W))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3afac422",
   "metadata": {},
   "source": [
    "Creating a color map for graph visualization"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "1e426c9e",
   "metadata": {},
   "outputs": [],
   "source": [
    "def create_color_map(size):\n",
    "    v = ['red' for i in range(size)]\n",
    "    return v"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b825ecd8",
   "metadata": {},
   "source": [
    "## Build graph on weight matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "d015bf7d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import networkx as nx\n",
    "import matplotlib.pyplot as plt\n",
    "def create_graph(M):\n",
    "    g = nx.Graph()\n",
    "    \n",
    "    g.add_nodes_from(create_vector_nodes(len(M)))\n",
    "    g.add_edges_from(create_edges(M))\n",
    "    return g\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5492f01f",
   "metadata": {},
   "source": [
    "Drawing the constructed graph"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "id": "60fbfd32",
   "metadata": {},
   "outputs": [],
   "source": [
    "def draw_graph(g):\n",
    "    color_map = create_color_map(len(g.nodes))\n",
    "    nx.draw(g, node_color=color_map, with_labels=True, alpha=0.8, node_size=500)\n",
    "  "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e8e4942c",
   "metadata": {},
   "source": [
    "Checking the construction of a graph by the matrix of the problem and its drawing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "id": "8c23a5aa",
   "metadata": {},
   "outputs": [
    {
     "data": {
